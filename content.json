{"posts":[{"title":"Algorithm","text":"algorithm头文件下的常用函数 常用函数有以下几种： max(x,y) 求两个数之中较大的那个 min(x,y) 求两个数中较小的那个 abs(x) 返回一个整数的绝对值这三种函数的使用样例如下： 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n = -5; int m = 2; cout &lt;&lt; max(n,m) &lt;&lt; endl; cout &lt;&lt; min(n,m) &lt;&lt; endl; cout &lt;&lt; abs(n) &lt;&lt; &quot; &quot; &lt;&lt; abs(m) &lt;&lt; endl; return 0;} 输出结果为：2-55 2 swap(x,y) 交换两个变量的值 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n = -5; int m = 2; cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; swap(n,m); //将 n 和 m 的值互换了 cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; return 0;} 输出结果为：-5 22 -5 reverse(it,it2) reverse(it,it2) 可以将数组指针在[it,it1)之间的元素或迭代器在[it,it1)范围内的元素进行反转。也可以对容器中的元素进行这样的操作例如：string 123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {1,2,3,4,5}; // reverse(arr,arr + 2); //将[arr,arr + 2)范围内的元素进行了反转 for(int i = 0;i &lt; 5;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; return 0;} 输出结果为：2 1 3 4 5 next-permutation() 给出一个序列在全排列下的下一个序列 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[5] = {1,2,3,4,5}; do{ printf(&quot;%d %d %d\\n&quot;,arr[0],arr[1],arr[2]); }while(next_permutation(arr,arr+3)); //将数组前三位赋值成了全排列中的下一列 return 0 ;} 输出结果为：1 3 22 1 32 3 13 1 23 2 1 fill() 可以把数组或容器中的某一段区域赋为一个相同的值 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[5]; fill(arr,arr+5,250); //将所有值都赋为250 for(int i = 0;i &lt; 5;i++){ printf(&quot;%d\\n&quot;,arr[i]); }} 输出结果为：250250250250250 sort() 它能够根据不同情况使用不同的排序方法效率较高，sort(首元素地址，尾元素地址的下一个地址，comp比较函数 (非必填) ),没有比较函数，那么sort函数默认是从小到大排序的 123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {24,11,67,43,5}; sort(arr,arr + 5); for(int i = 0;i &lt; 5;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; return 0;} 输出结果为：5 11 24 43 67 sort函数中的参数对double，(字典序排列)char类型的变量都同样适用，下面是compare比较函数的代码样例 12345678910111213141516#include &lt;iostream&gt;#include &lt;cstdbool&gt;#include &lt;algorithm&gt;using namespace std;bool compare(int a,int b){ return a &gt; b; //从大到小排序}int main(){ int arr[5] = {24,11,67,43,5}; sort(arr,arr + 5,compare); for(int i = 0;i &lt; 5;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; return 0;} 输出结果为：67 43 24 11 5 lower_bound(frist,last,val) 用来寻找在数组或容器[frist,last)范围内第一个值大于等于 val 的元素的位置 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {1,2,2,3,4}; int search = 2; cout &lt;&lt; lower_bound(arr,arr + 5,search) - arr; //函数返回找到的元素地址，减去arr就是数组下标 return 0; //没找到的话会返回所要找元素如果存在应该在的位置处的指针} 输出结果为：2 upper_bound(frist,last,val) 用来寻找在数组或容器[frist,last)范围内第一个值大于 val 的元素的位置 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {1,2,2,3,4}; int search = 2; cout &lt;&lt; upper_bound(arr,arr + 5,search) - arr; //函数返回找到的元素地址，减去arr就是数组下标 return 0; //没找到的话会返回所要找元素如果存在应该在的位置处的指针} 输出结果为：3","link":"/2022/08/11/Algorithm/"},{"title":"Bootstrap响应式布局","text":"Bootstrap响应式布局布局方式大致分为三种 固定宽度布局 流式布局 栅格式布局 响应式布局 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!--移动端的适配 输入meta:vp --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;!-- 让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。 --&gt; &lt;style&gt; body{ background-color: black; } @media screen and (min-width: 768px){ /*大于等于768*/ body{ background-color: red; } } @media screen and (min-width: 992px){ /*大于等于992*/ body{ background-color: green; } } @media screen and (min-width: 1200px){ /*大于等于1200*/ body{ background-color: blue; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2022/09/02/Bootstrap%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"},{"title":"DatabaseOverview","text":"第一章 数据库概述1.1.数据 数据的定义:数据是数据库中存储的基本对象， 描述数据的符号定义称为 数据 描述事物的符号可以是数据，例如 图片， 视频， 音频等 1.2. 数据库 数据库定义: 数据库是长期存储在计算机内，有组织的可共享的大量数据的集合，数据库中的数据按照一定的数据模型，组织，描述和存储，具有较小的数据冗余度，较高的数据独立性和易扩展性，并可以为各种用户共享 数据库数据特点: 永久存储，有组织，可扩展 1.3. 数据库管理系统 数据库系统和操作系统一样是计算机基础软件 数据库系统功能 (1). 数据定义功能 (2). 数据组织存储功能 (3). 数据操纵功能 (4). 数据库的事务管理和运行 (5). 数据的建立和维护 1.4. 数据库系统数据库系统是由数据库，数据库管理系统（及其应用开发工具），应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统 数据库系统的特点 数据结构化 数据库实现整体的结构化，是数据库系统和文件系统的主要区别 数据的共享度高冗余度低并且容易扩展 数据共享能大大减少数据冗余，节省存储空间 数据独立性高 数据独立性又分为 物理独立性和逻辑独立性 数据由数据库管理系统统一管理和控制 2.1 数据模型结构数据模型通常由 数据结构， 数据操作和数据的完整性约束条件 三部分组成 数据结构 数据结构描述数据之间的组成对象，以及对象之间的联系 数据操作 指对于数据库中各种对象的实例允许执行的操作集合 数据的完整性约束条件 是一组完整性规则 数据模型分为 层次模型， 网状模型， 关系模型，面向对象模型 模型名称 特点 优点 缺点 层次模型 (1). 有且只有一个节点没有双亲节点,且该节点为根节点 (2). 根以外的其他节点都有且仅有一个双亲节点 (1).层次模型的数据结构清晰 (2).层次数据模型查询效率高 (3).层次数据模型提供了良好的完整性支持 (1).现实中很多联系是非层次性的 (2). 节点具有多个双亲节点，用层次模型表示会显得比较笨拙 (3).查询子女必须通过双亲 (4).结构严密，层次命令趋于程序化 网状模型 (1). 允许一个以上节点无双亲 (2). 一个节点可以有多于一个的双亲 (1). 能直接描述现实世界 (2). 具有良好的性能，存储效率高 (1). 结构较复杂 (2). DDL， DML复杂，用户不容易掌握 (3). 编写应用程序负担较重 关系模型 (1). 建立在数学概念的基础之上 (1). 建立在严格的数学概念基础上 (2). 数据结构简单，清晰，易懂 (3).关系模型存储路径透明，具有更高的数据独立性 (1). 查询效率不高 3.1 数据库系统的三级模式结构 模式 是数据库中所有数据的逻辑结构和特征的描述 外模式 数据库用户能够看到和使用的局部数据的逻辑结构和特征的描述，是数据库用户的视图 内模式 一个数据库只有一个内模式，是数据物理结构和存储方式的描述","link":"/2022/08/30/DatabaseOverview/"},{"title":"Set","text":"Set的常见用法 set 是一个内部自动有序且不含重复元素的容器，如果需要使用 set需要加入头文件 #include &lt;*set*&gt;,还要再头文件下加上一段 using namespace std； 1.Set的定义 单独定义一个 set； set &lt;typename&gt; name; set &lt;typename&gt; name[SIZE]; //name[0],name[1]都是一个set容器 2.set容器内元素的访问 set 只能通过迭代器访问元素 set&lt;typename&gt;::iterator it; // typename 指的是元素的类型例如：int，char 除了vector，string之外的STL容器都不支持 *(it + i) 的访问方式12345678910111213141516#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ int arr[5] = {34,21,25,67,44}; set&lt;int&gt; st; for(int i = 0;i &lt; 5;i++){ st.insert(arr[i]); //将数组arr中的元素都插入了set容器中 } set&lt;int&gt;::iterator it = st.begin(); for(;it != st.end();it++){ printf(&quot;%3d&quot;,*it); //元素都被从小到大排好序了 } return 0;} 输出结果为： 21 25 34 44 67 3.Set常用函数(1) insert() insert(x) 函数可以将 x 插入到 set 容器中并自动排序和去重 ，时间复杂度为 O(logn) ,其中 n 为set中元素个数。 (2) find() find(value) 返回set中对应值为 value 的迭代器，找到对应元素的话返回对应元素的值的地址，找不到返回 st.end() 12345678910111213#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } printf(&quot;%3d&quot;,*(st.find(2))); return 0;} 输出结果为： 2； (3) erase() erase()有两种使用方法：一种是删除 set 中的单个元素，另一种是删除 set 某一个区间内的函数， 它们的参数均为元素的地址； 12345678910111213141516#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } st.erase(2); //将容器中的元素 2 删除了 for(it = st.begin();it != st.end();it++){ printf(&quot;%3d&quot;,*it); } return 0;} 输出结果为： 1 3 4 5； 12345678910111213141516#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } st.erase(st.find(3),st.end()); //将容器中 3 - 5 的元素都删除了 for(it = st.begin();it != st.end();it++){ printf(&quot;%3d&quot;,*it); } return 0;} (4) size() size()函数用来获得元素内的个数，时间复杂度为 O(l)； 12345678910111213#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } printf(&quot;%d&quot;,st.size()); //size 获取 st 容量的元素个数 return 0;} (5) clear() 用来清空 set 中所有的元素 1234567891011121314#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } st.clear(); //清空元素 printf(&quot;%d&quot;,st.size()); return 0;} 输出元素为：0；","link":"/2022/08/11/Set/"},{"title":"JQuery","text":"1. JQuery 概述 什么是 JQuery ? 快捷，简便的第三方 js库, 能够简化 dom 操作, 并且能屏蔽浏览器之间的兼容性问题。 工厂函数 $() 在 JQuery 中无论使用哪一种类型的选择符，都要从一个美元符号和圆括号开始，所有能在样式中使用的选择符，都能放到这个圆括号中的引号内 12345# Dom 查找 id 属性名为 myList 的标签document.getElementByld('myList');# JQuery$(&quot;#myList&quot;); 2. JQuery的增删改查 访问元素属性 12345//获取北京节点的name值$bj.attr(&quot;name&quot;);//设置北京节点的name值$bj.attr(&quot;name&quot;, &quot;beijing&quot;); html操作，读取或者修改HTML内容 123456// 获取 p 标签的 html 内容$(&quot;p&quot;).html()// 设置 p 标签的内容$(&quot;p&quot;).html(&quot;&lt;strong&gt;你最喜欢的水果是？&lt;/strong&gt;&quot;); 修改节点内容 12345// 获取 p 标签文本$(&quot;p&quot;).text();// 设置 p 标签内容$(&quot;p&quot;).text(&quot;&lt;strong&gt;你最喜欢的水果是？&lt;/strong&gt;&quot;) 值操作 12345// 获取 p 标签的 value 值$(&quot;p&quot;).val();// 修改 p 标签的 value 值$(&quot;p&quot;).val(&quot;我被点击了&quot;); 将新元素添加到 DOM 树中 12var $new = $(&quot;html&quot;);$(parent).append($new); 删除操作 123456$(...).remove(...);// 获取第二个 li 元素节点，将它从网页中删除$(&quot;ul li:eq(1)&quot;).remove();// 把 &lt;li&gt; 元素中属性 title 不等于 菠萝 的 li 标签全部删除$(&quot;ul li&quot;).remove(&quot;li[title != 菠萝]&quot;);","link":"/2022/08/19/JQuery/"},{"title":"c++快速读入","text":"关于c++的快速读入每次读入一个整数，可以在数据量较大的时候使用 1234567inline int read(){ int x=0,f=1;char ch=getchar(); while (ch&lt;'0'||ch&gt;'9'){if (ch=='-') f=-1;ch=getchar();} while (ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-48;ch=getchar();} return x*f;}","link":"/2022/09/12/c-%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/"},{"title":"cssGridLayout","text":"网格布局 CSS 网格布局模块（CSS Grid Layout Module）提供了带有行和列的基于网格的布局系统，它使网页设计变得更加容易，而无需使用浮动和定位。 Display 属性 当 HTML 元素的 display 属性设置为 grid 或 inline-grid 时，它就会成为网格容器。 网格列（Grid Columns） 网格项的垂直线被称为列。 网隔行（Grid Rows） 网格项的水平线被称为行。 网格间隙（Grid Gaps） 每列/行之间的间隔称为间隙。 您可以通过使用以下属性之一来调整间隙大小： grid-column-gap grid-row-gap grid-gap 参考自: https://www.w3school.com.cn/css/css_grid.asp","link":"/2022/08/18/cssGridLayout/"},{"title":"css布局与定位","text":"盒子模型 页面中的所有元素都能看成一个盒子，占据着一定的页面空间，每个盒子由 context (内容), border (边框), padding (内边距), margin (外边距, 注意!: 竖直方向会合并，水平方向不会)。如下图是盒子结构示意图 overflow 属性 属性 描述 hidden 超出部分不可见 scroll 显示滚动条 auto 如果有超出部分就显示滚动条 border 属性 注意！ 当图片间有间隙的时候设置 font-size: 0， 即可取消图片间的间隙 属性 描述 设置方法 border-width 盒子宽度 px, thin, medium, thick border-style 盒子类型 dashed, dotted, solid, double border-color 颜色 red … 123456789101112131415161718#newimg { text-align: center; font-size: 0;}#newimg img { height: 100px; width: 200px; padding: 20px; border: 10px dashed #0cf; /* 像素大小 线条样式 颜色 */ margin: 20px;}&lt;div id=&quot;newimg&quot;&gt; &lt;img src=&quot;./images/3index_r2_c2.png&quot;/&gt; &lt;img src=&quot;./images/3index_r2_c2.png&quot;/&gt; &lt;img src=&quot;./images/3index_r2_c2.png&quot;/&gt;&lt;/div&gt; 下图是上面html代码的效果图 css定位的三种方式 文件流定位: 默认从上到下， 从左到右的顺序摆放盒子，元素之间可以通过 display 进行修改转化 block: 独占一行，元素 height, width, margin, padding，都可以修改 inline: 不单独占用一行，元素 height, width, margin, padding，不可以修改 inline-block: 不单独占用一行，元素 height, width, margin, padding，都可以修改。 浮动定位: 可以设置并列一行的两个盒子 float: left, right clear: left, right, both 层定位: 设置覆盖层面的元素图片 属性 特点 描述 fixed 无 相对于浏览器定位 relative 保留原位置 相对于其直接父元素定位 absolute 不保留原位置 相对于非static类型父元素(若父元素中都是static类型，则取body)进行定位 left, right, top, bottom 无 设置相对于参照物的距离 z-index 无 设置网页层面优先级，优先级低的被覆盖","link":"/2022/08/15/css%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AE%9A%E4%BD%8D/"},{"title":"css三种添加方法","text":"css 的添加方式分为三种分别是 行内添加， 内嵌样式，单独文件 行内添加 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style=&quot;color: blue;&quot;&gt;ha ha ha!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 内嵌样式 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; h1{ color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;ha ha ha!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 单独文件","link":"/2022/08/12/css%E4%B8%89%E7%A7%8D%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/"},{"title":"css圆角边框与阴影","text":"圆角边框 border-radius border-top-left-radius 左上角的形状 border-top-right-radius 右上角的形状 border-bottom-left-radius 左下角的形状 border-bottom-right-radius 右下角的形状 1234567div { height: 100px; width: 150px; border: 1px solid blue; border-top-left-radius: 40px 20px; border-bottom-right-radius: 20px;} 阴影(box-shadow)","link":"/2022/08/19/css%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86%E4%B8%8E%E9%98%B4%E5%BD%B1/"},{"title":"css弹性盒子","text":"css弹性盒子 弹性盒子可以解决那些问题？ 使盒子中的元素水平垂直居中对齐 使盒子中元素之间的空隙平均分配 使元素自动占据盒子剩余空间 定义弹性盒子 属性 描述 设置参数 display 将普通盒子转化为弹性盒子 flex flex-direction 设置行布局, 列布局 row, row-reverse，column, column-reverse flex-wrap 设置弹性元素是否折叠 nowrap, wrap, wrap-reverse flex-flow 同时设置flex-direction, flex-wrap两个属性的值 eg: row wrap justify-content 元素在主轴的对齐方式 flex-start(主轴左边), center(中心位置), flex-end(主轴右边), space-between, space-around align-items 元素在辐轴上的对齐方式 flex-start, center, flex-end, stretch(不需要设置元素高度，会自动铺满容器的那一列) align-content 设置多行元素在容器中的整齐对齐方式 flex-start, center, flex-end, stretch, space-between, space-around flex-direction 属性布局 align-items 属性布局 弹性元素 flex-grow 属性 元素被拉大的比例，按比例分配容器剩余空间 默认值为零元素不占用空间 默认值为 n 占用空间中 n 份空间 1234567891011121314151617.flex-container{ display: flex; flex-direction: row; align-items: stretch;}.flex-items{ border: 1px solid;}div:nth-child(1){ flex-grow: 1;}div:nth-child(2){ flex-grow: 2;}div:nth-child(3){ flex-grow: 3;} 下图是上面css代码中三个元素的容器空间占比 flex-shrink 元素被压缩的比例 默认为 1 等比压缩 设置为 0 表示不压缩 flex-basis 元素在主轴上的默认尺寸，其优先级高于 width 属性 flex flex: flex-grow flex-shrink flex-basis order 子元素在容器中的排列顺序，order值越小越靠前。 align-self 设置单个弹性元素在辅轴上的对齐方式， align-itmes 设置的是全部弹性元素","link":"/2022/08/16/css%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/"},{"title":"css样式","text":"css样式 单位与颜色 单位 描述 px 像素 em 1em - 表示一个字符 2em - 表示两个字符，可以自动适应用户所使用的字体 % 百分比 颜色 描述 rgb(x, x, x) RGB取值，0 - 255 rgb(x%, x%, x%) RGB取值 0% - 255% rgba(x, x, x, x) 多一个参数表示透明度 #rrggbb 十六进制数表示颜色, eg: #ff0000 文本属性 属性 描述 取值 color 文本颜色 red, #f00, RGB(255, 0, 0) letter-spacing 字符间距 2px, -3px line-height 行高 14px, 1.5em, 120% text-align 对其方式 center, left, right, justify text-decoration 装饰线 none(去除超链接下划线), overline, underline, line-through text-indent 首行缩进 2em text-decoration 文字属性 属性 描述 设置方式 font 在一个声明中设置所有字体属性 font: bold 18px ‘幼圆’ font 字体系列 font-family: “Hiragino“, “Sans GB“… font-size 字号 14px, 120% font-style 斜体 italic font-weight 粗体 bold 背景样式 属性 描述 设置方式 background-color 颜色 red background-image 背景图片 url(&quot;logo.jpg&quot;) background-repeat 背景填充格式 repeat(重复填充背景), repeat-x(横向重复填充背景), repeat-y(纵向填充背景), no-repeat(不重复填充背景) background 背景简写设置顺序 颜色 图片 repeat 超链接样式 当要设置所用超链接样式的时候直接设置 a 标签的样式就好了 超链接设置具有一定的顺序， a:hover 需要位于 a:link, a:visited 之后进行设置， a:active 需要位于 a:hover 之后 属性 描述 a:link 普通的，未被访问的链接 a:visited 已经被访问了的链接 a:hover 鼠标指针悬停的链接 a:active 被点击时的链接 12345678910111213141516171819202122&lt;style&gt; a:link { text-decoration: none; color: #09f; /* 浅蓝色 */ } a:visited { text-decoration: none; color: red; /* 红色 */ } a:hover { text-decoration: underline; color: chartreuse; /* 绿色 */ font-size: 120%; } a:active { text-decoration: none; color: blue; /* 蓝色 */ }&lt;/style&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;a link ~ ~ ~ !&lt;/a&gt; 普通链接为浅蓝色， 访问过的链接变成蓝色， 鼠标悬停到的链接呈现绿色，并且字体放大 120%，字体下方有下划线，点击的时候变成蓝色，并跳转到百度页面。 列表 列表分为 ul (无序列表), ol (有序列表) 属性 描述 list-style 所有用于列表的属性，设置一个声明 list-style-image 为列表项标志设置图像 list-style-position 标志的位置 list-style-type 标志的类型 表格 表格大小设置 123456table { width: 500px; height: 200px; bored-collapse: collapse; /* (可以将表格之间的间隔清除, 如下图) */} border 设置方式 123table, td, th { border: 1px solid #eee;} css 奇偶选择器见 https://www.php.cn/css-tutorial-477973.html","link":"/2022/08/15/css%E6%A0%B7%E5%BC%8F/"},{"title":"css选择器","text":"css选择器 标签选择器 通过设计指定body, p 等标签来指定网页样式 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ background-color: #ccc; text-align:center; font-size:12px; } p{ font-family:黑体; font-size:16px; color: red; } h1{ font-family: 黑体; font-size:20px; } hr{ color:red; width:200px; } &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;hr /&gt; &lt;p&gt;正文的段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 类别 class 选择器 . 开头进行定义 ，用 class 属性进行引用， 可以多次引用。 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p{font-size:12px; } .one{font-size:18px; } .two{font-size:24px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;one&quot;&gt;类别1&lt;/p&gt; &lt;p class=&quot;one&quot;&gt;类别1&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;类别2&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;类别2&lt;/p&gt; &lt;p&gt;普通段落中的文字&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; id选择器 符号 # 开头定义，使用 id 属性进行引用，只能被引用一次 1234567891011121314151617181920212223&lt;!DOCTYPE HTML &gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; #one{ font-size:12px; } #two{ font-size:24px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;one&quot;&gt;文字1&lt;/p&gt; &lt;p id=&quot;two&quot;&gt;文字2&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 多个选择器的集体声明 同时声明多个标签，具有相同值 12345&lt;style type=&quot;text/css&quot;&gt; h1,p { text-align:center; }&lt;/style&gt; 选择器的镶嵌声明 p标签和span 标签之间间隔一个空格， 表示只有在p标签内使用span标签表示的内容才会将颜色设置为 red 12345&lt;style type=&quot;text/css&quot;&gt; p span{ color:red; }&lt;/style&gt; 全局选择器声明 字符 * 表示将所有标签格式都进行更改 12345&lt;style type=&quot;text/css&quot;&gt; * { text-align:center; } &lt;/style&gt; class 与 id 选择器混合使用 class 属性同时引用多个标签之间用 空格 (space) 隔开。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .one{font-size:18px; } .two{font-size:24px; } .red{ color: red; } .yellow{ color: yellow; } .left{ text-align: left; } .right{ text-align: right; } #my{ background-color: #ccc; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 多个class选择器混用，用空格分开 --&gt; &lt;p class=&quot;one red right&quot;&gt;这里的文字，18px红色，右对齐&lt;/p&gt; &lt;div class=&quot;one yellow left&quot;&gt;这里的文字，18px黄色，左对齐&lt;/div&gt; &lt;!-- id和class混用 --&gt; &lt;div id=&quot;my&quot; class=&quot;one yellow left&quot; &gt;这里的文字，18px黄色，左对齐，有背景色&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2022/08/15/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"css简写属性","text":"CSS 的简写属性 什么是 简写属性？ 简写属性 是可以让你同时设置好几个 CSS 属性值的 CSS 属性。使用简写属性，Web 开发人员可以编写更简洁、更具可读性的样式表，节省时间和精力。 CSS 规范定义简写属性的目的在于将那些关于同一主题的常见属性的定义集中在一起。比如 CSS 的 background 属性就是一个简写属性，它可以定义 background-color、background-image、background-repeat 和 background-position 的值。类似地，最常见的字体相关的属性可以使用 font 的简写，盒子（box）各方向的外边距（margin）可以使用 margin 这个简写。 边界情况 没有指定的值会被设置为它的初始值。这听起来似乎本来就很合理的样子，但这确实意味着，它将会覆盖之前设置的值。因此： 12background-color: red;background: url(images/bg.gif) no-repeat top right; 以上样式不会将 background 的 color 值设置为 red，而是 background-color 的默认值 transparent，因为第二条规则优先。 关键词 inherit 只可以应用于单独属性（individual properties），如果应用于一个简写属性（shorthand property），则必须整体应用，而能对简写属性值的每一个部分单独应用。由于单独属性的漏掉的值会被它们的初始值（initial value）替代，因此不可能允许单个属性通过省略继承的。这意味着让一个属性的值使用继承值的唯一方法就是使用值是 inherit 的普通属性（longhand property）。 简写属性不试图强制它们替代属性的值的特定顺序。这适用于当这些属性使用不同类型的值时，因为这个时候顺序并不重要。但当几个属性可以设置相同值的时候，就没那么简单了，要注意替代属性的特定顺序。 转载自: https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties","link":"/2022/08/13/css%E7%AE%80%E5%86%99%E5%B1%9E%E6%80%A7/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/08/11/hello-world/"},{"title":"function","text":"c++11 function 用法function是一个template，定义于头文件functional中。通过function&lt;int(int, int)&gt; 声明一个function类型，它是“接受两个int参数、返回一个int类型”的可调用对象，这里可调用对象可以理解为函数指针（指针指向一个函数，该函数有两个int类型参数，返回int类型，即：int (*p)(int, int) ）。 可调用对象：对于一个对象或表达式，如果可以对其使用调用运算符，则称该对象或表达式为可调用对象。 C++语言中有几种可调用对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。 和其他对象一样，可调用对象也有类型。例如，每个lambda有它自己唯一的（未命名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定。 保存普通函数 12345678void printA(int a){ cout &lt;&lt; a &lt;&lt; endl; }std::function&lt;void(int a)&gt; func;func = printA;func(2); //2 保存 lambda 函数 12std::function&lt;void()&gt; func_1 = [](){cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;}; func_1(); //hello world 保存成员函数 12345678910class Foo{ Foo(int num) : num_(num){} void print_add(int i) const {cout &lt;&lt; num_ + i &lt;&lt; endl;} int num_; };//保存成员函数std::function&lt;void(const Foo&amp;,int)&gt; f_add_display = &amp;Foo::print_add;Foo foo(2);f_add_display(foo,1);","link":"/2022/08/27/function/"},{"title":"html5新特性","text":"HTML5中vedio标签vedio介绍 &lt;video&gt; 元素提供了播放、暂停和音量控件来控制视频。同时 &lt;video&gt; 元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。&lt;video&gt; 与 &lt;/video&gt; 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。&lt;video&gt; 元素支持多个 &lt;video&gt; 元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式： 当前，&lt;video&gt; 元素支持三种视频格式： MP4, WebM, 和 Ogg 使用 DOM 进行控制 vedio HTML5 &lt;video&gt; 和 &lt;audio&gt; 元素同样拥有方法、属性和事件。&lt;video&gt; 和 &lt;audio&gt; 元素的方法、属性和事件可以使用JavaScript进行控制.其中的方法有用于播放、暂停以及加载等。其中的属性（比如时长、音量等）可以被读取或设置。其中的 DOM 事件能够通知您，比方说，&lt;video&gt; 元素开始播放、已暂停，已停止，等等。· 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;test&quot;&gt; &lt;!-- 检测用户是否点击按钮来执行javascripy函数 --&gt; &lt;button onclick=&quot;playPause()&quot;&gt;播放/暂停&lt;/button&gt; &lt;!-- width 设置 视频界面大小 source: 设置视频文件路径， type: 设置文件类型 --&gt; &lt;video id=&quot;myVideo&quot; width=&quot;420&quot;&gt; &lt;source src=&quot;../bili.mp4&quot; type=&quot;video/mp4&quot;&gt; 浏览器不支持HTML5:video &lt;/video&gt; &lt;/div&gt; &lt;script&gt; var v = document.getElementById(&quot;myVideo&quot;); //访问vedio 对象 function playPause() { if(v.paused) { // 通过判断 vedio 属性来判断视频播放还是暂停 v.play(); } else { v.pause(); } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML DOM Video 对象访问 Video 对象您可以通过使用 getElementById() 来访问 元素： 1var x = document.getElementById(&quot;myVideo&quot;); 创建 Video 对象您可以通过使用 document.createElement() 方法来创建 元素： 1var x = document.createElement(&quot;VIDEO&quot;); Video 对象属性 属性 描述 audioTracks 返回表示可用音频轨道的 AudioTrackList 对象。 autoplay 设置或返回是否在就绪（加载完成）后随即播放视频。 buffered 返回表示视频已缓冲部分的 TimeRanges 对象。 controller 返回表示视频当前媒体控制器的 controls 设置或返回视频是否应该显示控件（比如播放/暂停等）。 crossOrigin 设置或返回视频的 CORS 设置。 currentSrc 返回当前视频的 URL。 currentTime 设置或返回视频中的当前播放位置（以秒计）。 defaultMuted 设置或返回视频默认是否静音。 defaultPlaybackRate 设置或返回视频的默认播放速度。 duration 返回视频的长度（以秒计）。 ended 返回视频的播放是否已结束。 error 返回表示视频错误状态的 MediaError 对象。 height 设置或返回视频的 height 属性的值。 loop 设置或返回视频是否应在结束时再次播放。 mediaGroup 设置或返回视频所属媒介组合的名称。 muted 设置或返回是否关闭声音。 networkState 返回视频的当前网络状态。 paused 设置或返回视频是否暂停。 playbackRate 设置或返回视频播放的速度。 played 返回表示视频已播放部分的 TimeRanges 对象。 poster 设置或返回视频的 poster 属性的值。 preload 设置或返回视频的 preload 属性的值。 readyState 返回视频当前的就绪状态。 seekable 返回表示视频可寻址部分的 TimeRanges 对象。 seeking 返回用户当前是否正在视频中进行查找。 src 设置或返回视频的 src 属性的值。 startDate 返回表示当前时间偏移的 Date 对象。 textTracks 返回表示可用文本轨道的 TextTrackList 对象。 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象。 volume 设置或返回视频的音量。 width 设置或返回视频的 width 属性的值。 Video 对象方法 Method 描述 addTextTrack() 向视频添加新的文本轨道。 canPlayType() 检查浏览器是否能够播放指定的视频类型。 load() 重新加载视频元素。 play() 开始播放视频。 pause() 暂停当前播放的视频。 参考文献如下:https://www.w3cschool.cn/html5/html5-video.htmlhttps://www.w3cschool.cn/jsref/dom-obj-video.html","link":"/2022/08/31/html5%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"newpage","text":"firstsecondthird some context","link":"/2022/08/11/newpage/"},{"title":"vector","text":"Vector的一些常见的用法 要想使用vector，则需要加入头文件 #include &lt;vector&gt;并且要在头文件的下面加上 using namespace std; ,这样就可以在代码中使用vector了 1.vector的定义 vector&lt;typename&gt; name; vector&lt;int&gt; name; vector&lt;char&gt; name; vector&lt;double&gt; name; 上面的定义相当于是一个数组name[SIZE],其长度可以根据需要来变化 定义一个二维数组 vector &lt; vector&lt;typenamne&gt; &gt; name vector&lt;typename&gt; name[SIZE]; 如果 typename 也是STL容器的话，定义的时候要记得在 &gt;&gt; 之间加上空格 2.容器内元素的访问1.通过下标访问 和访问普通的数组一样，vector&lt;typename&gt; vt，vt[0],vt[1] …. 2.通过迭代器访问 创建一个类似于指针的迭代器vector&lt;typename&gt;:: it; 123456789101112131415#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; vector&lt;int&gt;::iterator it; //创建迭代器 for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); //在 vt 的末尾添加元素 } for(it = vt.begin();it != vt.end();it++){ printf(&quot;%3d&quot;,*it); }// begin 的作用是取 vt 的首地址，end是取末尾元素后一位的地址 return 0;} 输出结果为： 1 2 3 4 5; vector的迭代器不支持 it &lt; vt.end() 这种写法，只能用 it != vt.end()。 另外vector的迭代器还支持 it++和++it 的写法 最后需要指出，在常用的STL库中，只有在 vector 和 string 中才能使用 vt.begin() + 3 这种迭代器加上整数的操作。 vector 常用函数实例解析(1)push_back() push_back就是在vector后面添加一个元素 x，时间复杂度为 **O(l)**。 1234567891011121314#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); //将元素1，2，3依次插入vt的末尾 } for(int i = 0;i &lt; vt.size();i++){ //size会得到 vt 容量的大小 printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果： 1 2 3 4 5; (2)pop_back() 用来删除vector尾部的元素，时间复杂度为 O(l)。 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); //将元素1，2，3依次插入vt的末尾 } for(int i = 0;i &lt; vt.size();i++){ //size会得到 vt 容量的大小 printf(&quot;%3d&quot;,vt[i]); } printf(&quot;\\n&quot;); vt.pop_back(); //将vt末尾的元素删除了 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果为：1 2 3 4 51 2 3 4 (3) size() 用来获取vector中元素的个数,返回的是 unsigned类型的数据，时间复杂度为 O(l); 123456789101112#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } printf(&quot;%d&quot;,vt.size()); //返回vt元素个数 return 0;} 输出结果为：5 (4) clear() 清空vector中所有的元素，时间复杂度为 O(n),其中 n为vector中元素的个数 12345678910111213#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vt.clear(); //清空了vt中的元素 printf(&quot;%d&quot;,vt.size()); return 0;} (5) insert() **insert(it,i)**用来向任意迭代器中插入元素 i，时间复杂度为 O(n); 12345678910111213141516#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vt.insert(vt.begin() + 2, -1); //在第二位和第三位之间插入元素-1 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;}} 输出结果为： 1 2 -1 3 4 5 (6) erase() erase()用法有两种，一种是删除单个元素，另一种是删除一个区间内的所有元素 erase(it) 意为删除迭代器 it 处的一个元素 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vector&lt;int&gt;::iterator it; it = vt.begin() + 2; //it 指向了vector中的第三个元素 3 vt.erase(it); //将 3 删除了 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果为： 1 2 4 5； erase(frist,last) 意为删除 [frist,last] 这个区间内的的所有元素 123456789101112131415#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vt.erase(vt.begin(),vt.begin() + 3); //将 1,2,3 删除了 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果为： 4 5；","link":"/2022/08/11/vector/"},{"title":"z-index","text":"z-indexz-index 属性设定了一个定位元素及其后代元素或 flex 项目的 z-order。当元素之间重叠的时候，z-index 较大的元素会覆盖较小的元素在上层进行显示。对于一个已经定位的盒子（即其 position 属性值不是 static，这里要注意的是 CSS 把元素看作盒子），z-index 属性指定： 盒子在当前堆叠上下文中的堆叠层级。 盒子是否创建一个本地堆叠上下文。 语法: 12345678910111213/* 字符值 */z-index: auto;/* 整数值 */z-index: 0;z-index: 3;z-index: 289;z-index: -1;/* 使用负值降低优先级 *//* 全局值 */z-index: inherit;z-index: initial;z-index: unset; demo: html 123456&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;dashed-box&quot;&gt;Dashed box&lt;/div&gt; &lt;div class=&quot;gold-box&quot;&gt;Gold box&lt;/div&gt; &lt;div class=&quot;green-box&quot;&gt;Green box&lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021222324252627282930.wrapper { position: relative;}.dashed-box { position: relative; z-index: 1; border: dashed; height: 8em; margin-bottom: 1em; margin-top: 2em;}.gold-box { position: absolute; z-index: 3; /* put .gold-box above .green-box and .dashed-box */ background: gold; width: 80%; left: 60px; top: 3em;}.green-box { position: absolute; z-index: 2; /* put .green-box above .dashed-box */ background: lightgreen; width: 20%; left: 65%; top: -25px; height: 7em; opacity: 0.9;}","link":"/2022/08/13/z-index/"},{"title":"计算几何凸包问题","text":"凸包问题1.什么是凸包？简单来说，可以想象在平面中有一些点，这些点的集合为 X，我们拿一个橡皮圈撑到最大，尝试套住所有的点，待橡皮圈绷紧后，它会成为一个多边形，这个多边形所有顶点组成的集合便为集合 X 的凸包。如图： 2. Graham 扫描法先给出算法： 找到一个一定在凸包中的初始点，比如最左下的点 按逆时针逐个加入可能在凸包中的点。做法就是先把剩下的点集&gt;按照相对初始点的极角排序，如果极角相同，则按距离排序，近的在前（原因后面解释） 从初始点开始，按顺序不断加入凸包，对于加入的每一个点，判断加入该点后，会不会使凸包呈现一种前一个点往内凹陷的形状，如果是这样的，则从凸包中删除前一个点，继续往前判断（怎么判断形状呢？利用叉乘） 下面我来详细解释一下算法实现对点进行排序可以使用 atan，atan2 函数atan函数和atan2函数求角度的区别： 已知两点坐标求角度时，atan函数求角度时无方向（矢量），atan2函数求角度时有方向（矢量）。atan：-9090度atan2：-180180度例如：a（3,1），b（4,2） 方向ab, 求直线角度（与水平坐标线），atan：45°atan2：45°b（4,2），a（3,1） 方向ba, 求直线角度（与水平坐标线）,atan：45°, atan2：-135° 利用叉乘的原理对于平面中两个向量 $\\vec{a} = (x_a, x_a), \\vec{b} = (x_b, y_b)$, 他们的叉乘是一个向量，定义为: $\\vec{c} = \\vec{a} \\times \\vec{b} = (0, 0, x_ay_b - x_by_a)$, 向量 $\\vec{c}$ 垂直于这个平面，符合右手定则: $x_ay_b - x_by_a &gt; 0， 则 \\vec{b} 相对于 \\vec{a} 为顺时针$ $x_ay_b - x_by_a &lt; 0, 则 \\vec{b} 相对于 \\vec{a} 为逆时针$ $x_ay_b - x_by_a == 0, 则 \\vec{b} 与 \\vec{a}共线 $","link":"/2022/09/13/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"第二章关系数据库","text":"第二章关系数据库2.1 关系数据结构及其形式化定义2.1.1 关系 域 域是一组具有相同数据类型的值的集合 笛卡尔积笛卡尔积是域上的一种集合运算 给定一组域 $D_1, D_2, D_3 … D_n$, 允许其中某个域是相同的， $D_1, D_2, D_3 … D_n$的笛卡尔积为$D_1 \\times D_2 \\times D_3 \\times … \\times D_n$ = {$(d_1, d_2, d_3, …, d_n) | d_i \\in D_i, i = 1, 2, …, n $}","link":"/2022/11/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"C++_STL","slug":"C-STL","link":"/tags/C-STL/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"JQuery","slug":"JQuery","link":"/tags/JQuery/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"math","slug":"math","link":"/tags/math/"}],"categories":[{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"tecnology","slug":"tecnology","link":"/categories/tecnology/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"Computer","slug":"Computer","link":"/categories/Computer/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"computer","slug":"computer","link":"/categories/computer/"}],"pages":[]}