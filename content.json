{"posts":[{"title":"css三种添加方法","text":"css 的添加方式分为三种分别是 行内添加， 内嵌样式，单独文件 行内添加 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style=&quot;color: blue;&quot;&gt;ha ha ha!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 内嵌样式 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; h1{ color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;ha ha ha!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 单独文件","link":"/2022/08/12/css%E4%B8%89%E7%A7%8D%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/"},{"title":"Algorithm","text":"algorithm头文件下的常用函数 常用函数有以下几种： max(x,y) 求两个数之中较大的那个 min(x,y) 求两个数中较小的那个 abs(x) 返回一个整数的绝对值这三种函数的使用样例如下： 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n = -5; int m = 2; cout &lt;&lt; max(n,m) &lt;&lt; endl; cout &lt;&lt; min(n,m) &lt;&lt; endl; cout &lt;&lt; abs(n) &lt;&lt; &quot; &quot; &lt;&lt; abs(m) &lt;&lt; endl; return 0;} 输出结果为：2-55 2 swap(x,y) 交换两个变量的值 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n = -5; int m = 2; cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; swap(n,m); //将 n 和 m 的值互换了 cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; return 0;} 输出结果为：-5 22 -5 reverse(it,it2) reverse(it,it2) 可以将数组指针在[it,it1)之间的元素或迭代器在[it,it1)范围内的元素进行反转。也可以对容器中的元素进行这样的操作例如：string 123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {1,2,3,4,5}; // reverse(arr,arr + 2); //将[arr,arr + 2)范围内的元素进行了反转 for(int i = 0;i &lt; 5;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; return 0;} 输出结果为：2 1 3 4 5 next-permutation() 给出一个序列在全排列下的下一个序列 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[5] = {1,2,3,4,5}; do{ printf(&quot;%d %d %d\\n&quot;,arr[0],arr[1],arr[2]); }while(next_permutation(arr,arr+3)); //将数组前三位赋值成了全排列中的下一列 return 0 ;} 输出结果为：1 3 22 1 32 3 13 1 23 2 1 fill() 可以把数组或容器中的某一段区域赋为一个相同的值 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[5]; fill(arr,arr+5,250); //将所有值都赋为250 for(int i = 0;i &lt; 5;i++){ printf(&quot;%d\\n&quot;,arr[i]); }} 输出结果为：250250250250250 sort() 它能够根据不同情况使用不同的排序方法效率较高，sort(首元素地址，尾元素地址的下一个地址，comp比较函数 (非必填) ),没有比较函数，那么sort函数默认是从小到大排序的 123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {24,11,67,43,5}; sort(arr,arr + 5); for(int i = 0;i &lt; 5;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; return 0;} 输出结果为：5 11 24 43 67 sort函数中的参数对double，(字典序排列)char类型的变量都同样适用，下面是compare比较函数的代码样例 12345678910111213141516#include &lt;iostream&gt;#include &lt;cstdbool&gt;#include &lt;algorithm&gt;using namespace std;bool compare(int a,int b){ return a &gt; b; //从大到小排序}int main(){ int arr[5] = {24,11,67,43,5}; sort(arr,arr + 5,compare); for(int i = 0;i &lt; 5;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; return 0;} 输出结果为：67 43 24 11 5 lower_bound(frist,last,val) 用来寻找在数组或容器[frist,last)范围内第一个值大于等于 val 的元素的位置 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {1,2,2,3,4}; int search = 2; cout &lt;&lt; lower_bound(arr,arr + 5,search) - arr; //函数返回找到的元素地址，减去arr就是数组下标 return 0; //没找到的话会返回所要找元素如果存在应该在的位置处的指针} 输出结果为：2 upper_bound(frist,last,val) 用来寻找在数组或容器[frist,last)范围内第一个值大于 val 的元素的位置 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[5] = {1,2,2,3,4}; int search = 2; cout &lt;&lt; upper_bound(arr,arr + 5,search) - arr; //函数返回找到的元素地址，减去arr就是数组下标 return 0; //没找到的话会返回所要找元素如果存在应该在的位置处的指针} 输出结果为：3","link":"/2022/08/11/Algorithm/"},{"title":"Set","text":"Set的常见用法 set 是一个内部自动有序且不含重复元素的容器，如果需要使用 set需要加入头文件 #include &lt;*set*&gt;,还要再头文件下加上一段 using namespace std； 1.Set的定义 单独定义一个 set； set &lt;typename&gt; name; set &lt;typename&gt; name[SIZE]; //name[0],name[1]都是一个set容器 2.set容器内元素的访问 set 只能通过迭代器访问元素 set&lt;typename&gt;::iterator it; // typename 指的是元素的类型例如：int，char 除了vector，string之外的STL容器都不支持 *(it + i) 的访问方式12345678910111213141516#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ int arr[5] = {34,21,25,67,44}; set&lt;int&gt; st; for(int i = 0;i &lt; 5;i++){ st.insert(arr[i]); //将数组arr中的元素都插入了set容器中 } set&lt;int&gt;::iterator it = st.begin(); for(;it != st.end();it++){ printf(&quot;%3d&quot;,*it); //元素都被从小到大排好序了 } return 0;} 输出结果为： 21 25 34 44 67 3.Set常用函数(1) insert() insert(x) 函数可以将 x 插入到 set 容器中并自动排序和去重 ，时间复杂度为 O(logn) ,其中 n 为set中元素个数。 (2) find() find(value) 返回set中对应值为 value 的迭代器，找到对应元素的话返回对应元素的值的地址，找不到返回 st.end() 12345678910111213#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } printf(&quot;%3d&quot;,*(st.find(2))); return 0;} 输出结果为： 2； (3) erase() erase()有两种使用方法：一种是删除 set 中的单个元素，另一种是删除 set 某一个区间内的函数， 它们的参数均为元素的地址； 12345678910111213141516#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } st.erase(2); //将容器中的元素 2 删除了 for(it = st.begin();it != st.end();it++){ printf(&quot;%3d&quot;,*it); } return 0;} 输出结果为： 1 3 4 5； 12345678910111213141516#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } st.erase(st.find(3),st.end()); //将容器中 3 - 5 的元素都删除了 for(it = st.begin();it != st.end();it++){ printf(&quot;%3d&quot;,*it); } return 0;} (4) size() size()函数用来获得元素内的个数，时间复杂度为 O(l)； 12345678910111213#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } printf(&quot;%d&quot;,st.size()); //size 获取 st 容量的元素个数 return 0;} (5) clear() 用来清空 set 中所有的元素 1234567891011121314#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i = 1;i &lt;= 5;i++){ st.insert(i); } st.clear(); //清空元素 printf(&quot;%d&quot;,st.size()); return 0;} 输出元素为：0；","link":"/2022/08/11/Set/"},{"title":"css弹性盒子","text":"css弹性盒子 弹性盒子可以解决那些问题？ 使盒子中的元素水平垂直居中对齐 使盒子中元素之间的空隙平均分配 使元素自动占据盒子剩余空间 定义弹性盒子 属性 描述 设置参数 display 将普通盒子转化为弹性盒子 flex flex-direction 设置行布局, 列布局 row, row-reverse，column, column-reverse flex-wrap 设置弹性元素是否折叠 nowrap, wrap, wrap-reverse flex-flow 同时设置flex-direction, flex-wrap两个属性的值 eg: row wrap justify-content 元素在主轴的对齐方式 flex-start(主轴左边), center(中心位置), flex-end(主轴右边), space-between, space-around align-items 元素在辐轴上的对齐方式 flex-start, center, flex-end, stretch(不需要设置元素高度，会自动铺满容器的那一列) align-content 设置多行元素在容器中的整齐对齐方式 flex-start, center, flex-end, stretch, space-between, space-around flex-direction 属性布局 align-items 属性布局 弹性元素 flex-grow 属性 元素被拉大的比例，按比例分配容器剩余空间 默认值为零元素不占用空间 默认值为 n 占用空间中 n 份空间 1234567891011121314151617.flex-container{ display: flex; flex-direction: row; align-items: stretch;}.flex-items{ border: 1px solid;}div:nth-child(1){ flex-grow: 1;}div:nth-child(2){ flex-grow: 2;}div:nth-child(3){ flex-grow: 3;} 下图是上面css代码中三个元素的容器空间占比 flex-shrink 元素被压缩的比例 默认为 1 等比压缩 设置为 0 表示不压缩 flex-basis 元素在主轴上的默认尺寸，其优先级高于 width 属性 flex flex: flex-grow flex-shrink flex-basis order 子元素在容器中的排列顺序，order值越小越靠前。 align-self 设置单个弹性元素在辅轴上的对齐方式， align-itmes 设置的是全部弹性元素","link":"/2022/08/16/css%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/"},{"title":"css网格布局","text":"","link":"/2022/08/18/css%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"title":"css布局与定位","text":"盒子模型 页面中的所有元素都能看成一个盒子，占据着一定的页面空间，每个盒子由 context (内容), border (边框), padding (内边距), margin (外边距, 注意!: 竖直方向会合并，水平方向不会)。如下图是盒子结构示意图 overflow 属性 属性 描述 hidden 超出部分不可见 scroll 显示滚动条 auto 如果有超出部分就显示滚动条 border 属性 注意！ 当图片间有间隙的时候设置 font-size: 0， 即可取消图片间的间隙 属性 描述 设置方法 border-width 盒子宽度 px, thin, medium, thick border-style 盒子类型 dashed, dotted, solid, double border-color 颜色 red … 123456789101112131415161718#newimg { text-align: center; font-size: 0;}#newimg img { height: 100px; width: 200px; padding: 20px; border: 10px dashed #0cf; /* 像素大小 线条样式 颜色 */ margin: 20px;}&lt;div id=&quot;newimg&quot;&gt; &lt;img src=&quot;./images/3index_r2_c2.png&quot;/&gt; &lt;img src=&quot;./images/3index_r2_c2.png&quot;/&gt; &lt;img src=&quot;./images/3index_r2_c2.png&quot;/&gt;&lt;/div&gt; 下图是上面html代码的效果图 css定位的三种方式 文件流定位: 默认从上到下， 从左到右的顺序摆放盒子，元素之间可以通过 display 进行修改转化 block: 独占一行，元素 height, width, margin, padding，都可以修改 inline: 不单独占用一行，元素 height, width, margin, padding，不可以修改 inline-block: 不单独占用一行，元素 height, width, margin, padding，都可以修改。 浮动定位: 可以设置并列一行的两个盒子 float: left, right clear: left, right, both 层定位: 设置覆盖层面的元素图片 属性 特点 描述 fixed 无 相对于浏览器定位 relative 保留原位置 相对于其直接父元素定位 absolute 不保留原位置 相对于非static类型父元素(若父元素中都是static类型，则取body)进行定位 left, right, top, bottom 无 设置相对于参照物的距离 z-index 无 设置网页层面优先级，优先级低的被覆盖","link":"/2022/08/15/css%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AE%9A%E4%BD%8D/"},{"title":"css简写属性","text":"CSS 的简写属性 什么是 简写属性？ 简写属性 是可以让你同时设置好几个 CSS 属性值的 CSS 属性。使用简写属性，Web 开发人员可以编写更简洁、更具可读性的样式表，节省时间和精力。 CSS 规范定义简写属性的目的在于将那些关于同一主题的常见属性的定义集中在一起。比如 CSS 的 background 属性就是一个简写属性，它可以定义 background-color、background-image、background-repeat 和 background-position 的值。类似地，最常见的字体相关的属性可以使用 font 的简写，盒子（box）各方向的外边距（margin）可以使用 margin 这个简写。 边界情况 没有指定的值会被设置为它的初始值。这听起来似乎本来就很合理的样子，但这确实意味着，它将会覆盖之前设置的值。因此： 12background-color: red;background: url(images/bg.gif) no-repeat top right; 以上样式不会将 background 的 color 值设置为 red，而是 background-color 的默认值 transparent，因为第二条规则优先。 关键词 inherit 只可以应用于单独属性（individual properties），如果应用于一个简写属性（shorthand property），则必须整体应用，而能对简写属性值的每一个部分单独应用。由于单独属性的漏掉的值会被它们的初始值（initial value）替代，因此不可能允许单个属性通过省略继承的。这意味着让一个属性的值使用继承值的唯一方法就是使用值是 inherit 的普通属性（longhand property）。 简写属性不试图强制它们替代属性的值的特定顺序。这适用于当这些属性使用不同类型的值时，因为这个时候顺序并不重要。但当几个属性可以设置相同值的时候，就没那么简单了，要注意替代属性的特定顺序。 转载自: https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties","link":"/2022/08/13/css%E7%AE%80%E5%86%99%E5%B1%9E%E6%80%A7/"},{"title":"css样式","text":"css样式 单位与颜色 单位 描述 px 像素 em 1em - 表示一个字符 2em - 表示两个字符，可以自动适应用户所使用的字体 % 百分比 颜色 描述 rgb(x, x, x) RGB取值，0 - 255 rgb(x%, x%, x%) RGB取值 0% - 255% rgba(x, x, x, x) 多一个参数表示透明度 #rrggbb 十六进制数表示颜色, eg: #ff0000 文本属性 属性 描述 取值 color 文本颜色 red, #f00, RGB(255, 0, 0) letter-spacing 字符间距 2px, -3px line-height 行高 14px, 1.5em, 120% text-align 对其方式 center, left, right, justify text-decoration 装饰线 none(去除超链接下划线), overline, underline, line-through text-indent 首行缩进 2em text-decoration 文字属性 属性 描述 设置方式 font 在一个声明中设置所有字体属性 font: bold 18px ‘幼圆’ font 字体系列 font-family: “Hiragino“, “Sans GB“… font-size 字号 14px, 120% font-style 斜体 italic font-weight 粗体 bold 背景样式 属性 描述 设置方式 background-color 颜色 red background-image 背景图片 url(&quot;logo.jpg&quot;) background-repeat 背景填充格式 repeat(重复填充背景), repeat-x(横向重复填充背景), repeat-y(纵向填充背景), no-repeat(不重复填充背景) background 背景简写设置顺序 颜色 图片 repeat 超链接样式 当要设置所用超链接样式的时候直接设置 a 标签的样式就好了 超链接设置具有一定的顺序， a:hover 需要位于 a:link, a:visited 之后进行设置， a:active 需要位于 a:hover 之后 属性 描述 a:link 普通的，未被访问的链接 a:visited 已经被访问了的链接 a:hover 鼠标指针悬停的链接 a:active 被点击时的链接 12345678910111213141516171819202122&lt;style&gt; a:link { text-decoration: none; color: #09f; /* 浅蓝色 */ } a:visited { text-decoration: none; color: red; /* 红色 */ } a:hover { text-decoration: underline; color: chartreuse; /* 绿色 */ font-size: 120%; } a:active { text-decoration: none; color: blue; /* 蓝色 */ }&lt;/style&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;a link ~ ~ ~ !&lt;/a&gt; 普通链接为浅蓝色， 访问过的链接变成蓝色， 鼠标悬停到的链接呈现绿色，并且字体放大 120%，字体下方有下划线，点击的时候变成蓝色，并跳转到百度页面。 列表 列表分为 ul (无序列表), ol (有序列表) 属性 描述 list-style 所有用于列表的属性，设置一个声明 list-style-image 为列表项标志设置图像 list-style-position 标志的位置 list-style-type 标志的类型 表格 表格大小设置 123456table { width: 500px; height: 200px; bored-collapse: collapse; /* (可以将表格之间的间隔清除, 如下图) */} border 设置方式 123table, td, th { border: 1px solid #eee;} css 奇偶选择器见 https://www.php.cn/css-tutorial-477973.html","link":"/2022/08/15/css%E6%A0%B7%E5%BC%8F/"},{"title":"newpage","text":"firstsecondthird some context","link":"/2022/08/11/newpage/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/08/11/hello-world/"},{"title":"css选择器","text":"css选择器 标签选择器 通过设计指定body, p 等标签来指定网页样式 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ background-color: #ccc; text-align:center; font-size:12px; } p{ font-family:黑体; font-size:16px; color: red; } h1{ font-family: 黑体; font-size:20px; } hr{ color:red; width:200px; } &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;hr /&gt; &lt;p&gt;正文的段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 类别 class 选择器 . 开头进行定义 ，用 class 属性进行引用， 可以多次引用。 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p{font-size:12px; } .one{font-size:18px; } .two{font-size:24px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;one&quot;&gt;类别1&lt;/p&gt; &lt;p class=&quot;one&quot;&gt;类别1&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;类别2&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;类别2&lt;/p&gt; &lt;p&gt;普通段落中的文字&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; id选择器 符号 # 开头定义，使用 id 属性进行引用，只能被引用一次 1234567891011121314151617181920212223&lt;!DOCTYPE HTML &gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; #one{ font-size:12px; } #two{ font-size:24px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;one&quot;&gt;文字1&lt;/p&gt; &lt;p id=&quot;two&quot;&gt;文字2&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 多个选择器的集体声明 同时声明多个标签，具有相同值 12345&lt;style type=&quot;text/css&quot;&gt; h1,p { text-align:center; }&lt;/style&gt; 选择器的镶嵌声明 p标签和span 标签之间间隔一个空格， 表示只有在p标签内使用span标签表示的内容才会将颜色设置为 red 12345&lt;style type=&quot;text/css&quot;&gt; p span{ color:red; }&lt;/style&gt; 全局选择器声明 字符 * 表示将所有标签格式都进行更改 12345&lt;style type=&quot;text/css&quot;&gt; * { text-align:center; } &lt;/style&gt; class 与 id 选择器混合使用 class 属性同时引用多个标签之间用 空格 (space) 隔开。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .one{font-size:18px; } .two{font-size:24px; } .red{ color: red; } .yellow{ color: yellow; } .left{ text-align: left; } .right{ text-align: right; } #my{ background-color: #ccc; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 多个class选择器混用，用空格分开 --&gt; &lt;p class=&quot;one red right&quot;&gt;这里的文字，18px红色，右对齐&lt;/p&gt; &lt;div class=&quot;one yellow left&quot;&gt;这里的文字，18px黄色，左对齐&lt;/div&gt; &lt;!-- id和class混用 --&gt; &lt;div id=&quot;my&quot; class=&quot;one yellow left&quot; &gt;这里的文字，18px黄色，左对齐，有背景色&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2022/08/15/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"z-index","text":"z-indexz-index 属性设定了一个定位元素及其后代元素或 flex 项目的 z-order。当元素之间重叠的时候，z-index 较大的元素会覆盖较小的元素在上层进行显示。对于一个已经定位的盒子（即其 position 属性值不是 static，这里要注意的是 CSS 把元素看作盒子），z-index 属性指定： 盒子在当前堆叠上下文中的堆叠层级。 盒子是否创建一个本地堆叠上下文。 语法: 12345678910111213/* 字符值 */z-index: auto;/* 整数值 */z-index: 0;z-index: 3;z-index: 289;z-index: -1;/* 使用负值降低优先级 *//* 全局值 */z-index: inherit;z-index: initial;z-index: unset; demo: html 123456&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;dashed-box&quot;&gt;Dashed box&lt;/div&gt; &lt;div class=&quot;gold-box&quot;&gt;Gold box&lt;/div&gt; &lt;div class=&quot;green-box&quot;&gt;Green box&lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021222324252627282930.wrapper { position: relative;}.dashed-box { position: relative; z-index: 1; border: dashed; height: 8em; margin-bottom: 1em; margin-top: 2em;}.gold-box { position: absolute; z-index: 3; /* put .gold-box above .green-box and .dashed-box */ background: gold; width: 80%; left: 60px; top: 3em;}.green-box { position: absolute; z-index: 2; /* put .green-box above .dashed-box */ background: lightgreen; width: 20%; left: 65%; top: -25px; height: 7em; opacity: 0.9;}","link":"/2022/08/13/z-index/"},{"title":"vector","text":"Vector的一些常见的用法 要想使用vector，则需要加入头文件 #include &lt;vector&gt;并且要在头文件的下面加上 using namespace std; ,这样就可以在代码中使用vector了 1.vector的定义 vector&lt;typename&gt; name; vector&lt;int&gt; name; vector&lt;char&gt; name; vector&lt;double&gt; name; 上面的定义相当于是一个数组name[SIZE],其长度可以根据需要来变化 定义一个二维数组 vector &lt; vector&lt;typenamne&gt; &gt; name vector&lt;typename&gt; name[SIZE]; 如果 typename 也是STL容器的话，定义的时候要记得在 &gt;&gt; 之间加上空格 2.容器内元素的访问1.通过下标访问 和访问普通的数组一样，vector&lt;typename&gt; vt，vt[0],vt[1] …. 2.通过迭代器访问 创建一个类似于指针的迭代器vector&lt;typename&gt;:: it; 123456789101112131415#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; vector&lt;int&gt;::iterator it; //创建迭代器 for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); //在 vt 的末尾添加元素 } for(it = vt.begin();it != vt.end();it++){ printf(&quot;%3d&quot;,*it); }// begin 的作用是取 vt 的首地址，end是取末尾元素后一位的地址 return 0;} 输出结果为： 1 2 3 4 5; vector的迭代器不支持 it &lt; vt.end() 这种写法，只能用 it != vt.end()。 另外vector的迭代器还支持 it++和++it 的写法 最后需要指出，在常用的STL库中，只有在 vector 和 string 中才能使用 vt.begin() + 3 这种迭代器加上整数的操作。 vector 常用函数实例解析(1)push_back() push_back就是在vector后面添加一个元素 x，时间复杂度为 **O(l)**。 1234567891011121314#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); //将元素1，2，3依次插入vt的末尾 } for(int i = 0;i &lt; vt.size();i++){ //size会得到 vt 容量的大小 printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果： 1 2 3 4 5; (2)pop_back() 用来删除vector尾部的元素，时间复杂度为 O(l)。 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); //将元素1，2，3依次插入vt的末尾 } for(int i = 0;i &lt; vt.size();i++){ //size会得到 vt 容量的大小 printf(&quot;%3d&quot;,vt[i]); } printf(&quot;\\n&quot;); vt.pop_back(); //将vt末尾的元素删除了 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果为：1 2 3 4 51 2 3 4 (3) size() 用来获取vector中元素的个数,返回的是 unsigned类型的数据，时间复杂度为 O(l); 123456789101112#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } printf(&quot;%d&quot;,vt.size()); //返回vt元素个数 return 0;} 输出结果为：5 (4) clear() 清空vector中所有的元素，时间复杂度为 O(n),其中 n为vector中元素的个数 12345678910111213#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vt.clear(); //清空了vt中的元素 printf(&quot;%d&quot;,vt.size()); return 0;} (5) insert() **insert(it,i)**用来向任意迭代器中插入元素 i，时间复杂度为 O(n); 12345678910111213141516#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vt.insert(vt.begin() + 2, -1); //在第二位和第三位之间插入元素-1 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;}} 输出结果为： 1 2 -1 3 4 5 (6) erase() erase()用法有两种，一种是删除单个元素，另一种是删除一个区间内的所有元素 erase(it) 意为删除迭代器 it 处的一个元素 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vector&lt;int&gt;::iterator it; it = vt.begin() + 2; //it 指向了vector中的第三个元素 3 vt.erase(it); //将 3 删除了 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果为： 1 2 4 5； erase(frist,last) 意为删除 [frist,last] 这个区间内的的所有元素 123456789101112131415#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vt; for(int i = 1;i &lt;= 5;i++){ vt.push_back(i); } vt.erase(vt.begin(),vt.begin() + 3); //将 1,2,3 删除了 for(int i = 0;i &lt; vt.size();i++){ printf(&quot;%3d&quot;,vt[i]); } return 0;} 输出结果为： 4 5；","link":"/2022/08/11/vector/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"C++_STL","slug":"C-STL","link":"/tags/C-STL/"},{"name":"test","slug":"test","link":"/tags/test/"}],"categories":[{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"Tecnology","slug":"Tecnology","link":"/categories/Tecnology/"}],"pages":[]}